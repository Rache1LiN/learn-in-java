# 实验四
## 1.先来先服务
### a.题目
    任务(Task)的ID、开始时间和服务时间由文件读入，形如右图所示。这个任务列表文件首先由程序生成，每秒一个任务达到，服务时间由{6,2,1,3,9}这个集合中的数据随机获取。文件列表要包含至少100个任务。
    先要求实现如下要求的FCFS
    当只有一个处理队列时的情况
    当有两个处理队列时的情况
### b.主要代码
    public void fscsSingle(SortedSet<Task> ts){
		int lastFinTime=0;
		Task t=new Task();
		Iterator<Task> iterator=ts.iterator();
		for(int i=1;i<=100;i++)
		{
			t=iterator.next();
			if(t.getArrTime()>=lastFinTime)
				t.setStart(t.getArrTime());
			else
				t.setStart(lastFinTime);
			t.setFinish(t.getStartTime()+t.getSerTime());
			t.setTurnAround(t.getFinTime()-t.getArrTime());
			t.setWeight((double)t.getTurnAround()/t.getSerTime());
			lastFinTime=t.getFinTime();
		}
	}
	public void fscsDouble(SortedSet<Task> ts){
		int lastTime1=0;
		int lastTime2=0;
		Task t=new Task();
		Iterator<Task> iterator=ts.iterator();
		for(int i=1;i<=100;i++){
			t=iterator.next();
			if(t.getArrTime()>=lastTime1 && t.getArrTime()>=lastTime2)
			{
				t.setStart(t.getArrTime());
				t.setFinish(t.getStartTime()+t.getSerTime());
				t.setTurnAround(t.getFinTime()-t.getArrTime());
				t.setWeight((double)t.getTurnAround()/t.getSerTime());
				if((t.getArrTime()-lastTime1)>=(t.getArrTime()-lastTime2))
				{
					
					t.setTag(1);
					
					lastTime1=t.getFinTime();
				}
				else 
				{
					t.setTag(2);
					lastTime2=t.getFinTime();
					
				}
				
			}
			else if(t.getArrTime()>=lastTime1 || t.getArrTime()>=lastTime2)
			{
				if(t.getArrTime()>=lastTime1)
				{
					t.setStart(t.getArrTime());
					t.setTag(1);
					t.setFinish(t.getStartTime()+t.getSerTime());
					t.setTurnAround(t.getFinTime()-t.getArrTime());
					t.setWeight((double)t.getTurnAround()/t.getSerTime());
					lastTime1=t.getFinTime();
				}
				else
				{
					t.setStart(t.getArrTime());
					t.setTag(2);
					t.setFinish(t.getStartTime()+t.getSerTime());
					t.setTurnAround(t.getFinTime()-t.getArrTime());
					t.setWeight((double)t.getTurnAround()/t.getSerTime());
					lastTime2=t.getFinTime();
				}
			}
			else if(t.getArrTime()<lastTime1 && t.getArrTime()<lastTime2)
			{
				if((lastTime1-t.getArrTime())<=(lastTime2-t.getArrTime()))
				{
					t.setStart(lastTime1);
					t.setTag(1);
					t.setFinish(t.getStartTime()+t.getSerTime());
					t.setTurnAround(t.getFinTime()-t.getArrTime());
					t.setWeight((double)t.getTurnAround()/t.getSerTime());
					lastTime1=t.getFinTime();
				}
				else
				{
					t.setStart(lastTime2);
					t.setTag(2);
					t.setFinish(t.getStartTime()+t.getSerTime());
					t.setTurnAround(t.getFinTime()-t.getArrTime());
					t.setWeight((double)t.getTurnAround()/t.getSerTime());
					lastTime2=t.getFinTime();
				}
			}
			
		}
	}
	
### c.实验结果截图
![image](https://note.youdao.com/yws/public/resource/2a0dd81ab8b0480ee518859ceadab258/xmlnote/0A625C9DE5CD41268028AF792A937BE4/77)
![image](https://note.youdao.com/yws/public/resource/2a0dd81ab8b0480ee518859ceadab258/xmlnote/A8EA297573CF4EBA98B8E1FFF19BF779/95)
![image](https://note.youdao.com/yws/public/resource/2a0dd81ab8b0480ee518859ceadab258/xmlnote/2B75046B1EF6433E9A6DA1C19D19E0AA/102)
![image](https://note.youdao.com/yws/public/resource/2a0dd81ab8b0480ee518859ceadab258/xmlnote/D8FCF406BC4042FE91E3C7B6E8E7EA75/108)
![image](https://note.youdao.com/yws/public/resource/2a0dd81ab8b0480ee518859ceadab258/xmlnote/C196A5BDCA5F423BA61BFE4016D8A19D/110)
![image](https://note.youdao.com/yws/public/resource/2a0dd81ab8b0480ee518859ceadab258/xmlnote/A9739484CD8C480783647275829CA9F5/112)
## 2.短作业优先
### a.题目
    SJF算法首先调度已到达的任务中，服务时间最短的任务，这里不要求实现任务的抢占。
    按照FCFS算法的要求实现SJF算法，同样要求处理两种情况：
        当只有一个处理队列时的情况
        当有两个处理队列时的情况
        
### b.主要代码
    public int updateSingle(SortedSet<Task> ts,int ID,int lastTime)
	{
		Task t=new Task();
		Iterator<Task> iterator=ts.iterator();
		for(int i=0;i<100;i++)
		{
			t=iterator.next();
			if(t.getID()==ID)
			{
				break;
			}
		}
		if(t.getArrTime()>=lastTime)
			t.setStart(t.getArrTime());
		else
			t.setStart(lastTime);
		t.setFinish(t.getStartTime()+t.getSerTime());
		t.setTurnAround(t.getFinTime()-t.getArrTime());
		t.setWeight((double)t.getTurnAround()/t.getSerTime());
		t.setTag(1);
		lastTime=t.getFinTime();
		return lastTime;
		
	}
	
	public int[] updateDouble(SortedSet<Task> ts,int ID,int [] lastTime)
	{
		int lastTime1=lastTime[0];
		int lastTime2=lastTime[1];
		Task t=new Task();
		Iterator<Task> iterator=ts.iterator();
		for(int i=0;i<100;i++)
		{
			t=iterator.next();
			if(t.getID()==ID)
			{
				break;
			}
		}
		if(t.getArrTime()>=lastTime1 && t.getArrTime()>=lastTime2)
		{
			t.setStart(t.getArrTime());
			t.setFinish(t.getStartTime()+t.getSerTime());
			t.setTurnAround(t.getFinTime()-t.getArrTime());
			t.setWeight((double)t.getTurnAround()/t.getSerTime());
			if((t.getArrTime()-lastTime1)>=(t.getArrTime()-lastTime2))
			{
				
				t.setTag(1);
				
				lastTime1=t.getFinTime();
			}
			else 
			{
				t.setTag(2);
				lastTime2=t.getFinTime();
				
			}
			
		}
		else if(t.getArrTime()>=lastTime1 || t.getArrTime()>=lastTime2)
		{
			if(t.getArrTime()>=lastTime1)
			{
				t.setStart(t.getArrTime());
				t.setTag(1);
				t.setFinish(t.getStartTime()+t.getSerTime());
				t.setTurnAround(t.getFinTime()-t.getArrTime());
				t.setWeight((double)t.getTurnAround()/t.getSerTime());
				lastTime1=t.getFinTime();
			}
			else
			{
				t.setStart(t.getArrTime());
				t.setTag(2);
				t.setFinish(t.getStartTime()+t.getSerTime());
				t.setTurnAround(t.getFinTime()-t.getArrTime());
				t.setWeight((double)t.getTurnAround()/t.getSerTime());
				lastTime2=t.getFinTime();
			}
		}
		else if(t.getArrTime()<lastTime1 && t.getArrTime()<lastTime2)
		{
			if((lastTime1-t.getArrTime())<=(lastTime2-t.getArrTime()))
			{
				t.setStart(lastTime1);
				t.setTag(1);
				t.setFinish(t.getStartTime()+t.getSerTime());
				t.setTurnAround(t.getFinTime()-t.getArrTime());
				t.setWeight((double)t.getTurnAround()/t.getSerTime());
				lastTime1=t.getFinTime();
			}
			else
			{
				t.setStart(lastTime2);
				t.setTag(2);
				t.setFinish(t.getStartTime()+t.getSerTime());
				t.setTurnAround(t.getFinTime()-t.getArrTime());
				t.setWeight((double)t.getTurnAround()/t.getSerTime());
				lastTime2=t.getFinTime();
			}
		}
		lastTime[0]=lastTime1;
		lastTime[1]=lastTime2;
		return lastTime;
		
	}
	public int findMin(SortedSet<Task> ts,int lastTime)
	{
		Task k=new Task();
		int Min=10;
		int ID=0;
		Iterator<Task> iterator=ts.iterator();
		for(int j=0;j<100;j++)
		{
			k=iterator.next();
			if(k.getTag()==0)
			{
				
				if(k.getArrTime()<=lastTime)
				{
					if(Min>k.getSerTime())
					{
						Min=k.getSerTime();
						ID=k.getID();
					}
				}
			}
			
		}
		return ID;
	}
	
	public void sjfSingle(SortedSet<Task> ts)
	{
		int lastTime=0;
		int ID;
		
		for(int i=0;i<100;i++)
		{	
			ID=findMin(ts,lastTime);
			lastTime=updateSingle(ts,ID,lastTime);
		}
	}
	public void sjfDouble(SortedSet<Task> ts)
	{
		int lastTime[]={0,0};
		int MinTime;
		int ID;
		
		for(int i=0;i<100;i++)
		{	
			if(lastTime[0]>lastTime[1])
				MinTime=lastTime[1];
			else MinTime=lastTime[0];
			ID=findMin(ts,MinTime);
			lastTime=updateDouble(ts,ID,lastTime);
		}
	}
### c.实验结果截图
![image](https://note.youdao.com/yws/public/resource/2a0dd81ab8b0480ee518859ceadab258/xmlnote/DB8ADB50EC41453594F57B44CD466A52/129)
![image](https://note.youdao.com/yws/public/resource/2a0dd81ab8b0480ee518859ceadab258/xmlnote/AB56E62472A84D5EB2CB07F8DAC0974F/131)
![image](https://note.youdao.com/yws/public/resource/2a0dd81ab8b0480ee518859ceadab258/xmlnote/89D8E210D1B14633AB16F872177AED01/133)
![image](https://note.youdao.com/yws/public/resource/2a0dd81ab8b0480ee518859ceadab258/xmlnote/7095AA1DD9BE4741B1A2BE08F1470715/135)
![image](https://note.youdao.com/yws/public/resource/2a0dd81ab8b0480ee518859ceadab258/xmlnote/6370E49EBC1C4689A1A4817ED0397FE7/137)
![image](https://note.youdao.com/yws/public/resource/2a0dd81ab8b0480ee518859ceadab258/xmlnote/1E66282528F741FCA684A8F104CAA65C/139)